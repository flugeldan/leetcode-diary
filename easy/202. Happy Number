# 202. Happy Number
# Difficulty: Easy
# Link: https://leetcode.com/problems/happy-number/description/?envType=problem-list-v2&envId=math
I have wrote public solution to this problem on leetcode https://leetcode.com/problems/happy-number/solutions/6857152/0-ms-runtime-python-3-all-explained-by-f-vr8w/

Here i just gonna post on russian as note:
Так для начала, мы понимаем, что n должно складывать квадраты своих цифр столько раз, пока само n не будет равняться нулю и дальше уже не пойти.
У нас возникает фундаментальная проблема, что некоторые числа могут вести к бесконечному циклу в while, поскольку мы будем складывать квадраты
пока не придем к 1.
Допустим 2 -> 4(!) -> 37 -> 50 -> 25 ->29 -> 85 -> 89 -> 145 ->42->
20 -> 4(!)
Как мы видим число 4 уже встречается 2 раза, а значит оно точно приводит к самому себе, т.е это бесконечный луп.
Я думал, ну по сути легко, просто создать список и после каждого выполнения суммы, мы будем добавлять результат складывания в квадратов в список
Однако, count(), потребляет слишком много памяти, поскольку после каждого выполнения цикла for в while, ему придеться проходить по списку помня каждый элемент
После каждого цикла for. А это O(n^2), тогда мне в голову пришла идея, а что если использовать множества? Поскольку они не хранят один элемент дважды, т.е
Если мы уже положили его в множество, он проверит является ли это число элементом множества уже, и если да то остановит цикл и вернет False.
Суть проверки
Выдает сумму квадратов после цикла
Проверяем есть ли она в множестве seen
Если да -> return False
Если условие не выполнилось просто добавляем его в множество

почему с множеством быстрее чем с списком? 
В списке ему приходиться проходить и при этом помнить каунт, и при этом выполнять для каждого элемента списка if count>1

in для списка работает за O(n) — потому что Python перебирает каждый элемент по очереди.

count(n) делает то же самое, + ещё считает, сколько раз — тоже O(n).

Поэтому на каждой итерации программа тратит всё больше времени.

Множество в Python реализовано через хеш-таблицу.

in в set работает за O(1) — т.е. мгновенно (в среднем случае).

Python просто считает хеш числа и смотрит, есть ли оно в таблице.

list.count(x) работает за O(n) — он проходит весь список, сравнивая каждый элемент с x, и не останавливается, даже если уже нашёл нужное значение.

x in list тоже O(n) — проходит список слева направо до первого совпадения.

В задаче нужно много раз проверять, было ли число раньше, и это делает count() или in очень медленными при увеличении длины списка.

set реализован как хеш-таблица — проверка x in set и add(x) работают в O(1) в среднем случае.

Поэтому set обеспечивает постоянное время на проверку и добавление — это критически важно при большом количестве итераций.

просто запомнить что список проходит слева направо а множество каким то образом сразу достает
